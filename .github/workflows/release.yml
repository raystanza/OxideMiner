name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  RELEASE_TAG: ${{ github.ref_name }}

jobs:
  build:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-24.04
            target: x86_64-unknown-linux-gnu
            archive-extension: tar.gz
            binary-extension: ''
            linux_archive_label: x86_64-ubuntu24-linux-gnu
          - os: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            archive-extension: tar.gz
            binary-extension: ''
            linux_archive_label: x86_64-ubuntu22-linux-gnu
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive-extension: zip
            binary-extension: .exe
          - os: macos-15-intel
            target: x86_64-apple-darwin
            archive-extension: tar.gz
            binary-extension: ''
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustup toolchain install stable --profile minimal --no-self-update
          rustup default stable
          rustup target add ${{ matrix.target }}

      - name: Build oxide-miner
        shell: bash
        run: |
          set -euo pipefail
          cargo build --locked --release --target ${{ matrix.target }} -p oxide-miner

      # Resolve target dir
      - name: Resolve target dir
        shell: bash
        run: |
          set -euo pipefail
          if [[ -d "ox-build/target" ]]; then
            td="ox-build/target"
          else
            td="target"
          fi
          echo "CARGO_TARGET_DIR=$td" | tee -a "$GITHUB_ENV"
          echo "Resolved CARGO_TARGET_DIR: $td"

      - name: Set release metadata
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ matrix.os }}" == ubuntu-* ]]; then
            release_suffix="${{ matrix.linux_archive_label }}"
          else
            release_suffix="${{ matrix.target }}"
          fi
          echo "RELEASE_NAME=oxide-miner-${RELEASE_TAG}-${release_suffix}" >> "$GITHUB_ENV"
          echo "ARCHIVE_NAME=oxide-miner-${RELEASE_TAG}-${release_suffix}.${{ matrix.archive-extension }}" >> "$GITHUB_ENV"
          echo "CHECKSUM_NAME=oxide-miner-${RELEASE_TAG}-${release_suffix}.sha256" >> "$GITHUB_ENV"

      - name: List built files (Linux)
        if: ${{ startsWith(matrix.os, 'ubuntu-') }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Listing $CARGO_TARGET_DIR/${{ matrix.target }}/release and $CARGO_TARGET_DIR/release"
          ls -la "$CARGO_TARGET_DIR/${{ matrix.target }}/release" || true
          ls -la "$CARGO_TARGET_DIR/release" || true

      - name: Prepare Linux artifact (binary + config + scripts)
        if: ${{ startsWith(matrix.os, 'ubuntu-') || matrix.os == 'macos-15-intel' }}
        shell: bash
        run: |
          set -euo pipefail
          dist_dir="dist"
          mkdir -p "$dist_dir"

          # Prefer triple dir; fallback to host dir
          if [[ -d "$CARGO_TARGET_DIR/${{ matrix.target }}/release" ]]; then
            build_dir="$CARGO_TARGET_DIR/${{ matrix.target }}/release"
          elif [[ -d "$CARGO_TARGET_DIR/release" ]]; then
            build_dir="$CARGO_TARGET_DIR/release"
          else
            echo "No build output directory found."
            exit 1
          fi

          # Resolve binary path (hyphen or underscore)
          bin_hyphen="$build_dir/oxide-miner"
          bin_under="$build_dir/oxide_miner"
          if [[ -f "$bin_hyphen" ]]; then
            binary_path="$bin_hyphen"
          elif [[ -f "$bin_under" ]]; then
            binary_path="$bin_under"
          else
            echo "Built binary not found:"
            ls -la "$build_dir" || true
            exit 1
          fi

          # Staging folder (becomes top-level in archive)
          pkg_dir="$dist_dir/${RELEASE_NAME}"
          mkdir -p "$pkg_dir"

          # Copy binary (normalize to 'oxide-miner')
          install -m 0755 "$binary_path" "$pkg_dir/oxide-miner"

          # Include config.toml.example (root or crate path)
          if [[ -f "config.toml.example" ]]; then
            cp "config.toml.example" "$pkg_dir/"
          elif [[ -f "crates/oxide-miner/config.toml.example" ]]; then
            cp "crates/oxide-miner/config.toml.example" "$pkg_dir/"
          else
            echo "WARNING: config.toml.example not found; continuing"
          fi

          # Include scripts (windows & linux), exclude scripts/release
          if [[ -d "scripts/linux" ]]; then
            mkdir -p "$pkg_dir/scripts"
            cp -r "scripts/linux" "$pkg_dir/scripts/"
            chmod +x "$pkg_dir/scripts/linux/"*.sh || true
          fi
          if [[ -d "scripts/windows" ]]; then
            mkdir -p "$pkg_dir/scripts"
            cp -r "scripts/windows" "$pkg_dir/scripts/"
            # (PowerShell scripts don't need chmod on Linux, fine as-is)
          fi
          # Optional readme for scripts:
          if [[ -f "scripts/README.md" ]]; then
            mkdir -p "$pkg_dir/scripts"
            cp "scripts/README.md" "$pkg_dir/scripts/"
          fi

          # Include plugins (best-effort)
          if [[ -d "plugins" ]]; then
            cp -r "plugins" "$pkg_dir/"
            find "$pkg_dir/plugins" -type f -name "*.sh" -exec chmod +x {} + || true
          fi

          # Package the folder
          (cd "$dist_dir" && tar -czf "$ARCHIVE_NAME" "$RELEASE_NAME")
          rm -rf "$pkg_dir"

          # Checksums (archive only)
          if [[ "${{ matrix.os }}" == "macos-15-intel" ]]; then
            shasum -a 256 "$dist_dir/$ARCHIVE_NAME" > "$dist_dir/$CHECKSUM_NAME"
          else
            bash scripts/release/generate-checksums.sh "$dist_dir/$CHECKSUM_NAME" "$dist_dir/$ARCHIVE_NAME"
          fi

      # Setup GPG on Windows, with choco fallback
      - name: Ensure GnuPG (Windows)
        if: ${{ matrix.os == 'windows-latest' }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:GPG_PRIVATE_KEY) {
            Write-Host "No GPG key provided; skipping GnuPG setup."
            exit 0
          }
          if (Get-Command gpg -ErrorAction SilentlyContinue) {
            Write-Host "gpg already available:"
            gpg --version
          } else {
            choco install gnupg -y --no-progress
            gpg --version
          }

      - name: List built files (Windows)
        if: ${{ matrix.os == 'windows-latest' }}
        shell: pwsh
        run: |
          $dir1 = "$env:CARGO_TARGET_DIR\${{ matrix.target }}\release"
          $dir2 = "$env:CARGO_TARGET_DIR\release"
          Write-Host "Listing $dir1 and $dir2"
          if (Test-Path $dir1) { Get-ChildItem -Force $dir1 | Format-List Length,Name,FullName } else { Write-Host "Missing: $dir1" }
          if (Test-Path $dir2) { Get-ChildItem -Force $dir2 | Format-List Length,Name,FullName } else { Write-Host "Missing: $dir2" }

      - name: Prepare Windows artifact (binary + config + scripts)
        if: ${{ matrix.os == 'windows-latest' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $distDir = 'dist'
          New-Item -ItemType Directory -Path $distDir -Force | Out-Null

          # Prefer triple dir; fallback to host dir
          if (Test-Path "$env:CARGO_TARGET_DIR\${{ matrix.target }}\release") {
            $buildDir = "$env:CARGO_TARGET_DIR\${{ matrix.target }}\release"
          } elseif (Test-Path "$env:CARGO_TARGET_DIR\release") {
            $buildDir = "$env:CARGO_TARGET_DIR\release"
          } else {
            throw "No build output directory found."
          }

          # Resolve binary path
          $binHyphen = Join-Path $buildDir "oxide-miner${{ matrix.binary-extension }}"
          $binUnder  = Join-Path $buildDir "oxide_miner${{ matrix.binary-extension }}"
          if (Test-Path $binHyphen) {
            $binaryPath = $binHyphen
          } elseif (Test-Path $binUnder) {
            $binaryPath = $binUnder
          } else {
            Get-ChildItem -Force $buildDir | Format-List Length,Name,FullName
            throw "Binary not found"
          }

          # Staging folder (will be root in zip)
          $pkgDir = Join-Path $distDir $env:RELEASE_NAME
          New-Item -ItemType Directory -Path $pkgDir -Force | Out-Null

          # Copy binary (normalize to 'oxide-miner.exe')
          Copy-Item $binaryPath (Join-Path $pkgDir "oxide-miner${{ matrix.binary-extension }}") -Force

          # Include config.toml.example (root or crate path)
          if (Test-Path ".\config.toml.example") {
            Copy-Item ".\config.toml.example" $pkgDir -Force
          } elseif (Test-Path ".\crates\oxide-miner\config.toml.example") {
            Copy-Item ".\crates\oxide-miner\config.toml.example" $pkgDir -Force
          } else {
            Write-Host "WARNING: config.toml.example not found; continuing"
          }

          # Include scripts (windows & linux), exclude scripts/release
          if (Test-Path ".\scripts\windows") {
            New-Item -ItemType Directory -Path (Join-Path $pkgDir "scripts") -Force | Out-Null
            Copy-Item ".\scripts\windows" (Join-Path $pkgDir "scripts") -Recurse -Force
          }
          if (Test-Path ".\scripts\linux") {
            New-Item -ItemType Directory -Path (Join-Path $pkgDir "scripts") -Force | Out-Null
            Copy-Item ".\scripts\linux" (Join-Path $pkgDir "scripts") -Recurse -Force
          }
          if (Test-Path ".\scripts\README.md") {
            New-Item -ItemType Directory -Path (Join-Path $pkgDir "scripts") -Force | Out-Null
            Copy-Item ".\scripts\README.md" (Join-Path $pkgDir "scripts") -Force
          }
          if (Test-Path ".\plugins") {
            Copy-Item ".\plugins" (Join-Path $pkgDir "plugins") -Recurse -Force
          }

          # Zip the folder (keep top-level directory in the archive)
          Push-Location $distDir
          Compress-Archive -Path $env:RELEASE_NAME -DestinationPath $env:ARCHIVE_NAME -Force
          Pop-Location

          # Remove staging folder
          Remove-Item $pkgDir -Recurse -Force

          # Checksums (archive only)
          $archivePath = Join-Path $distDir $env:ARCHIVE_NAME
          $checksumFile = Join-Path $distDir $env:CHECKSUM_NAME
          $hash = Get-FileHash -Path $archivePath -Algorithm SHA256
          "$($hash.Hash.ToLower())  $($env:ARCHIVE_NAME)" | Out-File -FilePath $checksumFile -Encoding ascii

      - name: Sign artifacts (Linux)
        if: ${{ startsWith(matrix.os, 'ubuntu-') }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${GPG_PRIVATE_KEY:-}" ]]; then
            echo "No GPG_PRIVATE_KEY secret set; skipping signing."
            exit 0
          fi
          install -d -m 0700 ~/.gnupg
          echo "$GPG_PRIVATE_KEY" | base64 --decode | gpg --batch --import
          sign_args=(--batch --yes --armor --detach-sign)
          if [[ -n "${GPG_PASSPHRASE:-}" ]]; then
            sign_args+=(--pinentry-mode loopback --passphrase "$GPG_PASSPHRASE")
          fi
          for artifact in "dist/$ARCHIVE_NAME" "dist/$CHECKSUM_NAME"; do
            gpg "${sign_args[@]}" "$artifact"
          done

      - name: Sign artifacts (Windows)
        if: ${{ matrix.os == 'windows-latest' }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:GPG_PRIVATE_KEY) {
            Write-Host "No GPG_PRIVATE_KEY secret set; skipping signing."
            exit 0
          }
          $keyBytes = [Convert]::FromBase64String($env:GPG_PRIVATE_KEY)
          $keyPath = Join-Path $env:USERPROFILE 'gpg_private.key'
          [System.IO.File]::WriteAllBytes($keyPath, $keyBytes)
          & gpg --batch --yes --import $keyPath
          Remove-Item $keyPath
          $signArgs = @('--batch','--yes','--armor','--detach-sign')
          if ($env:GPG_PASSPHRASE) {
            $signArgs += @('--pinentry-mode','loopback','--passphrase',$env:GPG_PASSPHRASE)
          }
          foreach ($artifact in @((Join-Path 'dist' $env:ARCHIVE_NAME), (Join-Path 'dist' $env:CHECKSUM_NAME))) {
            & gpg @signArgs $artifact
          }

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: oxide-miner-${{ matrix.os }}-${{ matrix.target }}
          path: dist/*
          if-no-files-found: error

  release:
    name: Publish Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      # Needed for tag-based changelog generation;
      # "fetch-depth: 0" ensures tags/history are available.
      - name: Checkout repository for changelog
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: Create release notes
        shell: bash
        run: |
          set -euo pipefail
          echo "Generating changelog for ${RELEASE_TAG}..."
          mkdir -p dev
          changelog_file=$(bash scripts/release/list_changes_linux.sh --latest | sed -n 's/^Generated //p')
          if [[ -z "$changelog_file" || ! -f "$changelog_file" ]]; then
            echo "Changelog file not found after generation."
            ls -la dev
            exit 1
          fi
          echo "Using changelog file: $changelog_file"
          mkdir -p notes
          {
            echo "## OxideMiner ${RELEASE_TAG}"
            echo
            cat "$changelog_file"
          } > notes/body.md

      - name: Create release as draft if needed
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          if gh release view "${RELEASE_TAG}" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release ${RELEASE_TAG} already exists; assuming it was created by this workflow."
          else
            gh release create "${RELEASE_TAG}" \
              --repo "$GITHUB_REPOSITORY" \
              --title "OxideMiner ${RELEASE_TAG}" \
              --notes-file notes/body.md \
              --verify-tag \
              --draft
          fi

      - name: Upload release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          for asset in release-assets/*/*; do
            echo "Uploading $asset..."
            gh release upload "${RELEASE_TAG}" "$asset" --repo "$GITHUB_REPOSITORY" --clobber
          done

      - name: Publish release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Publishing release ${RELEASE_TAG}"
          gh release edit "${RELEASE_TAG}" \
            --repo "$GITHUB_REPOSITORY" \
            --draft=false
