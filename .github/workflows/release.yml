name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  RELEASE_TAG: ${{ github.ref_name }}

jobs:
  build:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            archive-extension: tar.gz
            binary-extension: ''
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive-extension: zip
            binary-extension: .exe
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        shell: bash
        run: |
          set -euo pipefail
          rustup toolchain install stable --profile minimal --no-self-update
          rustup default stable
          rustup target add ${{ matrix.target }}

      - name: Build oxide-miner
        shell: bash
        run: |
          set -euo pipefail
          cargo build --locked --release --target ${{ matrix.target }} -p oxide-miner

      # Resolve Cargo targe dir
      - name: Resolve target dir
        shell: bash
        run: |
          set -euo pipefail
          if [[ -d "ox-build/target" ]]; then
            td="ox-build/target"
          else
            td="target"
          fi
          echo "CARGO_TARGET_DIR=$td" | tee -a "$GITHUB_ENV"
          echo "Resolved CARGO_TARGET_DIR: $td"

      - name: Set release metadata
        shell: bash
        run: |
          set -euo pipefail
          echo "RELEASE_NAME=oxide-miner-${RELEASE_TAG}-${{ matrix.target }}" >> "$GITHUB_ENV"
          echo "ARCHIVE_NAME=oxide-miner-${RELEASE_TAG}-${{ matrix.target }}.${{ matrix.archive-extension }}" >> "$GITHUB_ENV"
          echo "CHECKSUM_NAME=oxide-miner-${RELEASE_TAG}-${{ matrix.target }}.sha256" >> "$GITHUB_ENV"

      - name: List built files (Linux)
        if: ${{ matrix.os == 'ubuntu-latest' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Listing $CARGO_TARGET_DIR/${{ matrix.target }}/release and $CARGO_TARGET_DIR/release"
          ls -la "$CARGO_TARGET_DIR/${{ matrix.target }}/release" || true
          ls -la "$CARGO_TARGET_DIR/release" || true

      - name: Prepare Linux artifact
        if: ${{ matrix.os == 'ubuntu-latest' }}
        shell: bash
        run: |
          set -euo pipefail
          dist_dir="dist"
          mkdir -p "$dist_dir"

          # Prefer triple dir; fallback to host dir
          if [[ -d "$CARGO_TARGET_DIR/${{ matrix.target }}/release" ]]; then
            build_dir="$CARGO_TARGET_DIR/${{ matrix.target }}/release"
          elif [[ -d "$CARGO_TARGET_DIR/release" ]]; then
            build_dir="$CARGO_TARGET_DIR/release"
          else
            echo "No build output directory found."
            exit 1
          fi

          # Resolve binary path (hyphen or underscore)
          bin_hyphen="$build_dir/oxide-miner"
          bin_under="$build_dir/oxide_miner"
          if [[ -f "$bin_hyphen" ]]; then
            binary_path="$bin_hyphen"
          elif [[ -f "$bin_under" ]]; then
            binary_path="$bin_under"
          else
            echo "Built binary not found at:"
            echo "  $bin_hyphen"
            echo "  $bin_under"
            echo "Available files in $build_dir:"
            ls -la "$build_dir" || true
            exit 1
          fi

          echo "Packaging binary from: $binary_path"
          install -m 0755 "$binary_path" "$dist_dir/${RELEASE_NAME}"
          (cd "$dist_dir" && tar -czf "$ARCHIVE_NAME" "$RELEASE_NAME")
          rm "$dist_dir/${RELEASE_NAME}"

          # Checksums
          bash scripts/release/generate-checksums.sh "$dist_dir/$CHECKSUM_NAME" "$dist_dir/$ARCHIVE_NAME"

      # Only set up GnuPG on Windows if we actually plan to sign
      - name: Ensure GnuPG (Windows)
        if: ${{ matrix.os == 'windows-latest' }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:GPG_PRIVATE_KEY) {
            Write-Host "No GPG key provided; skipping GnuPG setup."
            exit 0
          }
          if (Get-Command gpg -ErrorAction SilentlyContinue) {
            Write-Host "gpg already available:"
            gpg --version
          } else {
            choco install gnupg -y --no-progress
            gpg --version
          }

      - name: List built files (Windows)
        if: ${{ matrix.os == 'windows-latest' }}
        shell: pwsh
        run: |
          $dir1 = "$env:CARGO_TARGET_DIR\${{ matrix.target }}\release"
          $dir2 = "$env:CARGO_TARGET_DIR\release"
          Write-Host "Listing $dir1 and $dir2"
          if (Test-Path $dir1) { Get-ChildItem -Force $dir1 | Format-List Length,Name,FullName } else { Write-Host "Missing: $dir1" }
          if (Test-Path $dir2) { Get-ChildItem -Force $dir2 | Format-List Length,Name,FullName } else { Write-Host "Missing: $dir2" }

      - name: Prepare Windows artifact
        if: ${{ matrix.os == 'windows-latest' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $distDir = 'dist'
          New-Item -ItemType Directory -Path $distDir -Force | Out-Null

          # Prefer triple dir; fallback to host dir
          if (Test-Path "$env:CARGO_TARGET_DIR\${{ matrix.target }}\release") {
            $buildDir = "$env:CARGO_TARGET_DIR\${{ matrix.target }}\release"
          } elseif (Test-Path "$env:CARGO_TARGET_DIR\release") {
            $buildDir = "$env:CARGO_TARGET_DIR\release"
          } else {
            Write-Host "No build output directory found."
            exit 1
          }

          $binHyphen = Join-Path $buildDir "oxide-miner${{ matrix.binary-extension }}"
          $binUnder  = Join-Path $buildDir "oxide_miner${{ matrix.binary-extension }}"
          if (Test-Path $binHyphen) {
            $binaryPath = $binHyphen
          } elseif (Test-Path $binUnder) {
            $binaryPath = $binUnder
          } else {
            Write-Host "Built binary not found at $binHyphen or $binUnder"
            Get-ChildItem -Force $buildDir | Format-List -Property Length,Name,FullName
            throw "Binary not found"
          }

          $releaseName = "$env:RELEASE_NAME${{ matrix.binary-extension }}"
          Copy-Item $binaryPath (Join-Path $distDir $releaseName) -Force
          Compress-Archive -Path (Join-Path $distDir $releaseName) -DestinationPath (Join-Path $distDir $env:ARCHIVE_NAME)
          Remove-Item (Join-Path $distDir $releaseName)

          # Checksums
          $archivePath = Join-Path $distDir $env:ARCHIVE_NAME
          $checksumFile = Join-Path $distDir $env:CHECKSUM_NAME
          $hash = Get-FileHash -Path $archivePath -Algorithm SHA256
          "$($hash.Hash.ToLower())  $($env:ARCHIVE_NAME)" | Out-File -FilePath $checksumFile -Encoding ascii

      - name: Sign artifacts (Linux)
        if: ${{ matrix.os == 'ubuntu-latest' }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${GPG_PRIVATE_KEY:-}" ]]; then
            echo "No GPG_PRIVATE_KEY secret set; skipping signing."
            exit 0
          fi
          install -d -m 0700 ~/.gnupg
          echo "$GPG_PRIVATE_KEY" | base64 --decode | gpg --batch --import
          sign_args=(--batch --yes --armor --detach-sign)
          if [[ -n "${GPG_PASSPHRASE:-}" ]]; then
            sign_args+=(--pinentry-mode loopback --passphrase "$GPG_PASSPHRASE")
          fi
          for artifact in "dist/$ARCHIVE_NAME" "dist/$CHECKSUM_NAME"; do
            gpg "${sign_args[@]}" "$artifact"
          done

      - name: Sign artifacts (Windows)
        if: ${{ matrix.os == 'windows-latest' }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:GPG_PRIVATE_KEY) {
            Write-Host "No GPG_PRIVATE_KEY secret set; skipping signing."
            exit 0
          }
          $keyBytes = [Convert]::FromBase64String($env:GPG_PRIVATE_KEY)
          $keyPath = Join-Path $env:USERPROFILE 'gpg_private.key'
          [System.IO.File]::WriteAllBytes($keyPath, $keyBytes)
          & gpg --batch --yes --import $keyPath
          Remove-Item $keyPath
          $signArgs = @('--batch','--yes','--armor','--detach-sign')
          if ($env:GPG_PASSPHRASE) {
            $signArgs += @('--pinentry-mode','loopback','--passphrase',$env:GPG_PASSPHRASE)
          }
          foreach ($artifact in @((Join-Path 'dist' $env:ARCHIVE_NAME), (Join-Path 'dist' $env:CHECKSUM_NAME))) {
            & gpg @signArgs $artifact
          }

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: oxide-miner-${{ matrix.target }}
          path: dist/*
          if-no-files-found: error

  release:
    name: Publish Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: Create release notes
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p notes
          {
            echo "## OxideMiner ${RELEASE_TAG}"
            echo
            echo "Automated release for tag ${RELEASE_TAG}."
          } > notes/body.md

      - name: Create release if needed
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          if gh release view "${RELEASE_TAG}" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release ${RELEASE_TAG} already exists"
          else
            gh release create "${RELEASE_TAG}" \
              --repo "$GITHUB_REPOSITORY" \
              --title "OxideMiner ${RELEASE_TAG}" \
              --notes-file notes/body.md \
              --verify-tag
          fi

      - name: Upload release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          for asset in release-assets/*/*; do
            gh release upload "${RELEASE_TAG}" "$asset" --repo "$GITHUB_REPOSITORY" --clobber
          done
